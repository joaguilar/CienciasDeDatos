---
title: "Proyecto Final"
subtitle: "Inteligencia de Negocios y Mineria de Datos"
author: "Jose Aguilar, Eilyn Salazar, Crisia Piedra"
date: "1 de Junio, 2020"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!require(arules)) install.packages("arules",dependencies = TRUE)
library(arules)
if(!require(readxl)) install.packages("readxl",dependencies = TRUE)
library("readxl")
library(ggplot2)
library(knitr)
if(!require(kableExtra)) install.packages("kableExtra",dependencies = TRUE)
library(kableExtra)
library(arules)
library(arulesViz)

library(tidyverse)
if(!require(plyr)) install.packages("plyr",dependencies = TRUE)
library(plyr)
library(dplyr)
library(ggplot2)
library(knitr)
library(lubridate)
if(!require(assertr)) install.packages("assertr",dependencies = TRUE)
library(assertr)
if(!require(reshape2)) install.packages("reshape2",dependencies = TRUE)
library(reshape2)
#Librerias de Clustering
if(!require(cluster)) install.packages("cluster",dependencies = TRUE)
library(cluster)
if(!require(factoextra)) install.packages("factoextra",dependencies = TRUE)
library(factoextra)
if(!require(caTools)) install.packages("caTools",dependencies = TRUE)
library(caTools)
if(!require(rfm)) install.packages("rfm",dependencies = TRUE)
library(rfm)
if(!require(data.table)) install.packages("data.table",dependencies = TRUE)
library(data.table)
#Se establece el seed.
if(!require(viridis)) install.packages("viridis",dependencies = TRUE)
library(viridis)
set.seed(100)
```

# Fase de entendimiento del negocio
## Determinar los objetivos de negocio
### Objetivos de negocio
1.    Incrementar las ventas enfocándose en los diferentes tipos de clientes
2.    Mejorar la planeación de presupuestos mensuales a partir de los estimados de ventas a futuro.

### Criterios de éxito (en términos de negocio)
1.	Identificar los 3 segmentos de mercado más rentables para la empresa a fin de orientar la estrategia de ventas.
2.    Mejorar las estimaciones de ventas mensuales en un 20% de su valor real.

## Evaluación de la situación actual
Actualmente la compañía XYZ no cuenta con controles para crear sus presupuestos, lo cual hace que termine gastando mas o menos de lo que le producen las ventas y no tiene en general un sistema de _forecast_ efectivo. Por esta razón desea optimizar la gestión de sus presupeustos a partir de la información histórica disponible sobre las ventas de los diferentes productos que se comercializan.

Por otra parte, el departamento de mercadeo de la empresa desea optimizar su presupuesto enfocando sus esfuerzos en los clientes que son más rentables para la compañía para esto está considerando crear un programa de  fidelidad, sin embargo no cuenta con información sobre el perfil de sus mejores clientes.

### Inventario de recursos(datos, personal, TI)
####	Datos
*	Datos de ventas históricos de un año.

#### Personal
*	1 patrocinador del proyecto representando la gerencia. 
*	1 experto del área de mercadeo para apoyar la estrategia del negocio.
*	1 analista de datos con conocimiento de los sistemas y fuentes de datos.
*	1 desarrollador.

####	TI
Un ambiente virtualizado en la nube con las siguientes características. 
*	 OS: Window Server 2016
*	 RAM: 32 GB
*	 CPU: @2.4 GHz 2.39 GHz (8 processors)

#### Software
1.	R y  RStudio: Para análisis de datos.
2.	MySQL y MySQL Workbench: Fuentes, almacenamiento de datos y herramientas de modelado y consulta.
3.	Tableau: Visualización de datos
4.	Notepad++ y Visual Studio Code: Desarrollo y revisión de logs de sistema.

### Requerimientos

####	Seguridad

*	Solo la gerencia de mercadeo y la gerencia general tendrá acceso a los resultados de la investigación realizada.

#### Legales /Confidencialidad
*	Considerando las políticas de confidencialidad y el manejo de los datos personales de los clientes, este proyecto no debe hacer uso de datos personales para su análisis.

#### Implementación y mantenimiento

*	Considerando que se utilizará un ambiente virtualizado en la nube, se requiere el uso de VPNs para el acceso al área de desarrollo.
*	Todos los equipos utilizados para el análisis deben contar con los parches de sistema operativo y antivirus actualizado.
*	El despliegue de los resultados del modelo, y reportes generados se realizará mediante el uso de la herramienta Tableau. 

#### Cronograma
*	Se estima que la duración del proyecto no podrá exceder más de 1 mes.

### Supuestos
*	Se cuenta con acceso a datos de ventas de 1 año.
*	La compañía cuenta con los recursos técnicos para satisfacer los requerimientos técnicos del proyecto.
*	El proyecto cuenta con la aprobación del negocio y el personal capacitado para ser desarrollado.

### Restricciones
*	Solo se cuenta con 1 año de datos históricos. 
*	La información de clientes es limitada por motivos de privacidad.
*	Ausencia de información sobre las categorías de cada producto.

### Riesgos y contingencias
```{r warning=FALSE,echo=FALSE}
atributos<-read.csv('riesgos.csv', sep = ',',dec = '.')
kable(atributos[,0:3],caption = "Riesgos y Contingencias")%>%
kable_styling(bootstrap_options = c("striped", "hover"))

```

### Beneficios
*	Reducción de gastos por almacenamiento de inventarios y evitar compras innecesarias.
*	Mejora en la tasa de retención de clientes
*	Incremento en las ganancias gracias a la mayor disponibilidad de inventario para los productos más vendidos.

## Determinar los objetivos de minería de datos

### Objetivos de minería de datos
*	Identificar 3 segmentos de mercados minoristas a partir de las ventas.
*	Crear un modelo de predicción de ventas.
 

### Criterios de éxito (desde la perspectiva de minería de datos)
1.	Identificar 3 clústeres de clientes de la compañía basados en su perfil de compras.
2.	Evaluar el modelo de predicción a fin de validar que la predicción se encuentre dentro de un 20% de las ventas reales.

##Plan del proyecto

### Evaluación inicial de herramientas y técnicas
Para el desarrollo de este proyecto se utilizará el lenguaje de programación R, y la herramienta RStudio a fin de realizar al proceso de exploración de los datos e identificar las librerías y técnicas de minería de datos más apropiadas para la realización del mismo.

Para el cumplimiento de los objetivos de mineria se utilizaran las técnicas de clustering  K-means, y kmedoids, de igual manera para la predicción de las ventas se usara regresión lineal simple y múltiple.

### Plan del proyecto
Se debe señalar que la estimación inicial para el desarrollo del proyecto no debe de tardar más de 1 mes y por lo cual se consideran 24 días hábiles para la implementación del mismo, los cuales son distribuidos de la siguiente manera.

```{r warning=FALSE,echo=FALSE}
atributos<-read.csv('plan_proyecto.csv', sep = ',',dec = '.',encoding = "UTF-8")
kable(atributos[,0:5],caption = "Plan de Proyecto")%>%
kable_styling(bootstrap_options = c("striped", "hover"))
```

# Fase de entendimiento de los datos

## Recopilación inicial de datos

### Lista de datasets requeridos

Para el desarrollo de este trabajo se hará uso del conjunto de datos“Online Retail”. Este es un conjunto de datos transnacionales que contiene todas las transacciones que ocurren entre el 12/01/2010 y el 12/09/2011 para un minorista en línea registrado en el Reino Unido y sin tienda. La compañía vende principalmente regalos únicos para toda ocasión. 

#### Ubicación de los datasets

Este conjunto de datos se encuentra disponible en el Machine Learning Repository a través del siguiente url.

#### Método de acceso

El conjunto de datos puede ser descargado en formato .xlsx a través del siguiente link http://archive.ics.uci.edu/ml/machine-learning-databases/00352/


## Descripción de los datos

El conjunto de datos a utilizar cuenta “Retail Online” con 541910 observaciones de compras realizadas desde diciembre del 2010 hasta diciembre del 2011, cada una de las observaciones cuenta con 8 variables las cuales se describen a continuación.

```{r warning=FALSE,echo=FALSE}
atributos<-read.csv('atributos.csv', sep = ',',dec = '.')
kable(atributos[,0:3],caption = "Descripción de atributos")%>%
kable_styling(bootstrap_options = c("striped", "hover"))
```

## Exploración de los datos

Se aplicó la función summary para la obtención de las estadísticas básicas de cada variable del conjunto de datos. Por medio de este análisis es posible observar elementos interesantes como los valores mínimos y máximos de las cantidades. 

```{r data}
retail<-read_excel("Online Retail.xlsx")
summary(retail)

```

En el summary podemos ver algunas cosas interesantes, como por ejempo:

* Se identifican posibles valores default para variables como quantity con -80995.00 - es un valor irreal para una cantidad, por lo que es posible que sea el valor por defecto de este campo, y se obtiene como el valor mínimo en ese campo. 
* Otro de los detalles que logra observarse es como variables como CustomerID y Description tienen valores NA. 

Nota: En el caso de description es posible observar líneas en blanco al revisar las observaciones.   

Para efectos de la tarea se le dará prioridad a los siguientes campos:

* InvoiceNo: Sera utilizado para agrupar las compras.
* CustomerID: Sera utilizado para identificar los clientes que seran agrupados.
* Total: Campo derivado (ver siguiente sección) que facilitará los calculos de las ventas.
* InvoiceDay: Variable creada con la fecha del día de la compra 

Nota:

Las siguiente variables son utilizadas para la creacion del campo Total, mas no seran utilizadas directamente.

* Quantity: Sera utilizado para determinar el conjunto de productos mas vendidos.
* UnitPrice: Sera utilizado para determinar, junto con Quantity. las ventas a predecir.


#### Compras de clientes

De estos datos y basado en estas observaciones prelminares es posible crear algunos campos adicionales que pueden ayudar a la hora de manipularlos. Para inciar, vamos a crear estos dos campos adicionales:

| Campo  | Descripción | Tipo  |
|---|---|---|
| Total | Total de la compra del producto, resultado de multiplicar UnitPrice por Quantity | Numérico |
| InvoiceDay | Fecha de la compra sin la hora para sumarizar por día las compras | Fecha |

```{r  warning=FALSE}
retail$Total <- retail$UnitPrice * retail$Quantity
retail$InvoiceDay <- as.Date(format(retail$InvoiceDate,"%Y-%m-%d"))
```

Ademas podemos observar que existen variables que son actualmente hileras (strings) o numeros pero en realidad representan un factor, por lo que se realizan las siguientes conversiones para estas columnas:

| Campo  | Conversión | Nuevo Tipo  |
|---|---|---|
| StockCode | Convertirlo a un factor | Factor |
| Description | Convertirlo a un factor | Factor |
| Country | Convertirlo a un factor | Factor |
| CustomerID | Convertirlo a un factor | Factor |


```{r  warning=FALSE}
retail$StockCode <- as.factor(retail$StockCode)
retail$Description <- as.factor(retail$Description)
retail$Country <- as.factor(retail$Country)
retail$CustomerID <- as.factor(retail$CustomerID)
```


Podemos revisar algunas de estas variables y como se relacionan. Por ejemplo, en el siguiente gráfico se muestra el resultado de la multiplicación de las variables _UnitPrice_ y _Quantity_ (variable _Total_) agrupadas por cliente, y se muestran las compras totales de los 10 primeros clientes de la tabla:

```{r  warning=FALSE}
por_cliente <- retail[!is.na(retail$CustomerID),] %>%
  group_by(CustomerID) %>%
  summarise_at(vars(Total),funs(sum(.))) %>% 
  arrange(desc(Total))
pp<-ggplot(data=head(por_cliente,10), aes(x=CustomerID,y=Total)) +
  geom_bar(stat="identity") +
  scale_y_continuous(name="Total Sales (£)", labels = scales::comma)
pp
```

A través del customerID podemos ver las compras totales del cliente por ejemplo el cliente 14646 realizó compras totales por un monto de ￡279489 en 721 productos diferentes.


Podemos ver que productos compra:

```{r warning=FALSE}
#Agrupamos por productos:
un_cliente_productos <- subset(retail, CustomerID==14646) %>%
  group_by(StockCode,Description) %>%
  summarise_at(vars(Quantity,Total),list(~sum(.))) %>%
  arrange(desc(Total))
un_cliente_totales<-sum(un_cliente_productos$Total)
un_cliente_productos_diferentes<-nrow(un_cliente_productos)
```

Las compras totales del cliente son:

```{r}
print(un_cliente_totales)
```

en la siguiente cantidad de productos: 

```{r}
print(un_cliente_productos_diferentes)
```

La siguiente tabla es una muestra de los productos que adquirió, la cantidad que adquirió y el total de la venta:

```{r warning=FALSE}
kable(head(un_cliente_productos,10),"html", booktabs = T)%>%
kable_styling(latex_options = "striped")
```

Podemos ver que algunos clientes compran grandes cantidades - por ejemplo en este caso, el cliente compró 4801 unidades del producto RABBIT NIGHT LIGHT. Esto nos hace pensar que algunas de las cantidades grandes vistas anterioremente no son anómalas.


Los siguientes gráficos muestran el comportamiento de las ventas en el tiempo, así como la agrupación por país. 

Para observar las ventas por día, utilizamos la variable InvoiceDay, con el fin de eliminar la hora de la venta que no es de interés para este análisis.

```{r,warning = FALSE}
invoices <- retail %>% 
  group_by(InvoiceDay) %>%
  summarise_at(vars(Total),funs(sum(.)))
kable(head(invoices,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

```{r warning = FALSE}
p <- ggplot(invoices, aes(x=InvoiceDay, y=Total)) +
  geom_line() + 
  xlab("Fecha") +
  ylab("Ventas Totales") +
  ggtitle("Ventas totales por día")
p

```

```{r explore4, warning=FALSE}
por_pais <- retail %>%
  group_by(Country) %>%
  summarise_at(vars(Total),funs(sum(.))) %>% 
  arrange(desc(Total))
pp<-ggplot(data=head(por_pais,10), aes(x=Country,y=Total)) +
  geom_bar(stat="identity") +
  scale_y_continuous(name="Ventas totales (£)", labels = scales::comma) +
  ggtitle("Ventas totales por País")
pp
```

Y podemos ademas observar las cantidades de las ventas por país:

```{r warning=FALSE}
por_cantidad <- retail %>%
  group_by(Country) %>%
  summarise_at(vars(Quantity),funs(sum(.))) %>% 
  arrange(desc(Quantity))
pp<-ggplot(data=head(por_cantidad,10), aes(x=Country,y=Quantity)) +
  geom_bar(stat="identity") +
  scale_y_continuous(name="Ventas totales (Cantidad)", labels = scales::comma) +
  ggtitle("Ventas totales (cantidad) por País")
pp
```



## Verificación de la calidad de datos

Uno de los problemas de calidad detectados es el gran número de observaciones en donde el CustomerID tiene un valor NA, es decir no se tiene la información de cuáles fueron los clientes que realizaron las compras, lo cual puede influir en el análisis a realizar al no contar con esta información.

```{r warning=FALSE}
numclientesna <- count(is.na(retail$CustomerID))
library(ggplot2)
tmp_clientes<-data.frame(IdValido=c("Si", "No"), conteo=c(numclientesna[1,2],numclientesna[2,2]), index=1)
ggplot(tmp_clientes,aes(IdValido,conteo)) +
  geom_col(stat="identity")+
  scale_y_continuous(name="Observaciones", labels = scales::comma) +
  labs(x="Identificador valido de cliente?")+
  ggtitle("NA's en el campo CustomerID") +
  geom_text(aes(label=conteo))
```

Como se puede observar, hay 135080 NA - estos registros no pueden ser utilizados para el analisis de clientes a realizar, dejandonos solamente con los 406829 registros restantes.

Así mismo al analizar las variables de quantity y unit price, es posible ver que existen datos que a simple vista son anómalos como se muestra en las siguientes gráficas de caja.

```{r}
boxplot(retail$Quantity,data=retail,main="Datos de Quantity")
```

De acuerdo con esto, existen 58619 valores “outliers”. Dado que representa un número importante de valores es importante validar estos datos con el experto del negocio a fin de comprender su validez y de no ser completamente correcto, será necesario imputarlos de alguna forma - sin embargo, hay que tener cuidado dado que puede alterar significativamente los resultados.

Podemos hacer el mismo estudio con el campo UnitPrice

```{r}
boxplot(retail$UnitPrice,data=retail,main="Datos de UnitPrice")
```

De acuerdo con esto, existen 39627 valores “outliers” para UnitPrice. En este caso debemos hacer un tratamiento similar para los valores de la variable quantity.

Adicionalmente podemos revisar para los valores que representan montos de dinero (UnitPrice) o Cantidades, que los valores tengan sentido - podemos revisar por ejemplo que sean positivos:

Para Unit Price:

```{r warning=FALSE}
UnitPrice_Positivos<- nrow(retail[retail$UnitPrice >= 0,])
UnitPrice_Positivos
UnitPrice_Negativos<- nrow(retail[retail$UnitPrice < 0,])
UnitPrice_Negativos
kable(head(retail[retail$UnitPrice < 0,],10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

Podemos ver que solamente son dos valores negativos, y que por la descripcion que tienen, probablemente pueden ser ignorados.

Para Quantity:

```{r warning=FALSE}
Quantity_Positivos<- nrow(retail[retail$Quantity >= 0,])
Quantity_Positivos
Quantity_Negativos<- nrow(retail[retail$Quantity < 0,])
Quantity_Negativos

kable(head(retail[retail$Quantity < 0,]),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

Para las cantidades se puede observar que son muchos mas, `r Quantity_Negativos`. Es necesario revisar esto con los analistas del negocio. Sin embargo el hecho que una de las descripciones tenga el texto "Discount" nos hace pensar que tal vez sean por proceso de negocios - una forma de dar descuentos o de realizar devoluciones de productos.

# Fase de preparación de los datos

## Selección de datos: 
Debe describir y justificar con cuáles atributos trabajará o bien cuáles serán descartados, de igual forma, si se realiza una selección por filas, debe estar documentada y justificada.

```{r warning=FALSE}
datos_ge <- retail
summary(datos_ge)
```

### Selección de variables clave

* Quantity: Es la variable que nos indica cuales son las existencias que deben existir por cada producto para mejorar las existencias en inventarios basado en las ventas registradas. 

* Unit Price: En conjunto con la variable quantity nos permite realizar el cálculo del valor monetario de las ventas realizadas por cliente. 

* CustomerID: Nos permite agrupar las compras realizadas por el mismo cliente, esto con el fin de identificar cuáles son los mejores clientes de la compañía.

* Country: Nos permite analizar o agrupar el comportamiento de las compras por país.

* Total: Total es una variable derivada y nos permite obtener el monto total de las compras realizadas por cliente, para analizar cuales son los mejores clientes basados en las mismas.

* InvoiceDay: Se empleara el InvoiceDate para realizar la creacion de variables adicionales asociadas a la dimensión tiempo, como la "frescura" y frecuencia de las compras realizadas por los clientes.


Dado que el dataset solamente contiene 8 campos, no se descartará ninguna variable. Sin embargo si se evaluará descartar observaciones que presenten problemas como los outliers que se describen en la sección de Calidad de datos.

## Limpieza de datos

Basados en lo observado en la seccion de _Calidad de Datos_, podemos eliminar ciertos registros que son aportan a los modelos a realizar.

*Valores negativos en UnitPrice*

Existen dos registros que tienen este campo, UnitPrice, en negativo:

```{r warning=FALSE}
kable(head(datos_ge[datos_ge$UnitPrice < 0,],10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

Basandonos en la descricpción de estos registros, que corresponden a ajuste de deuda y no a un producto en particular, podemos eliminarlos sin problema del conjunto de datos:

```{r warning=FALSE}
retail <- datos_ge[!(datos_ge$UnitPrice < 0),]
kable(head(datos_ge[datos_ge$UnitPrice < 0,],10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")

```

*Valores negativos en Quantity*

Asimismo se observaron varios valores negativos en el campo Quantity que corresponden a devoluciones y consideran que este parametro no sera utilizado, se proce a removerlas del conjunto de observaciones:

```{r warning=FALSE}
kable(head(datos_ge[datos_ge$Quantity < 0,]),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
datos_ge <- datos_ge[!(datos_ge$Quantity < 0),]
kable(head(datos_ge[datos_ge$Quantity < 0,],10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

*Eliminación de Observaciones con valores NA*

Al analizar el conjunto de datos se observa que hay algunas observaciones con valores NA en las columnas CustomerID y descripción las cuales son eliminadas.
```{r warning=FALSE}
datos_ge <- datos_ge %>% drop_na(CustomerID, Description)
```

*Manejo de Outliers*

Para revisar los Outliers detectados en la sección de calidad de datos, se ejecuta un summary con el fin de determinar el mínimo, maximo, y otras caracteristicas de las columnas Quantity y UnitPrice:


```{r warning=FALSE}
summary(datos_ge)
```

## Construcción de nuevos datos


Para ambos modelos a construir se crearon nuevos datos basados en la información disponible.

Para los modelos de clustering, se crearon las siguientes variables a através de la función RFM (https://cran.r-project.org/web/packages/rfm/rfm.pdf)

* date_most_recent: fecha de la compras más reciente del cliente

* recency_days: muestra que tan reciente es la ultima compra de un cliente. Es la diferencia en dias, de las ultima fecha analizada, con la fecha de la última compra.

* transaction_count: que es la cantidad de compras o transacciones realizadas por el cliente

* Amount: el total del valor monetario de las compras del cliente

* recency_score: puntaje de antigüedad del cliente

* frequency_score: puntaje de frecuencia del cliente

* monetary_score: puntaje monetario del cliente

* rfm_score: puntaje RFM del cliente


Para el modelo de regresión se crearon 13 variables nuevas:

* diff: diferencia del monto vendido entre la fecha y la fecha del mes anterior

* lag: 12 variables de lag distribuidas a lo largo de los 13 meses, que contienen las diferencias entre las ventas distribuidas a lo largo de todos los meses.

## Transformaciones aplicadas

Para los modelos de clustering, se realizaron agrupaciones de los datos por cliente y por fecha, sumarizando las variables Total y el conteo de las compras realizadas por el cliente.

En el caso de los modelos de regresion, se agruparon los datos por fecha, sumarizando el total de ventas para esa fecha.



### Agrupamiento por Fecha

Se agrupan las compras de los clientes por fecha.

```{r,warning = FALSE}
historic_invoices <- datos_ge %>% 
  group_by(InvoiceDay,CustomerID) %>%
  summarise_at(vars(Total),funs(sum(.))) 
kable(head(historic_invoices,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")

```

### Agrupamiento de Clientes por pais

Guardamos una tabla con los clientes y su pais para utilizarla mas adelante.

```{r warning=FALSE,cache=TRUE}
clientes_pais <- datos_ge %>% 
  distinct(CustomerID, Country) %>%
  distinct(CustomerID, .keep_all = TRUE)
head(clientes_pais)
```


# Fase de Modelado

## Selección de las técnicas a utilizar

Para cubrir los objetivos planteados, se seleccionaron dos técnicas de aprendizaje automático - clustering y regresión. A continuación se detallan ambas técnicas.

### Clustering de clientes

Para realizar el clustering esta tarea se hará uso de las técnicas de agrupamiento Kmedoids y Kmedias a fin de comprar los resultados de ambas técnicas usando diferentes parámetros de K.

Para la construcción del modelo vamos a utilizar los datos que genera el modelo [RFM (*R*ecency, *F*requency, *M*onetary Value)](https://en.wikipedia.org/wiki/RFM_(market_research)), el cual utilizar 3 dimensiones de los clientes para definir su valor como clientes. Las tres dimensiones que utiliza son:

* Recency (Antiguedad) – Que tan reciente es la última compra del cliente?

* Frequency (Frequencia) – Que tan a menudo realizan una compra?

* Monetary Value (Valor Monetario) – Cuánto gasta en sus compras?

En este modelo se asigna un puntaje para cada una de estas categorias, por medio de una conversion simple:

* Recency: El maximo entre "10-el numero de meses desde la ultima compra) o 1.
* Frequency: El máximo entre el numero de compras por el cliente en los ultimos 12 meses o 1
* Monetary = El valor de la compra mas grande del cliente.

Sin embargo, para nuestro clustering, solamnete vamos a obtener los valores Antiguedad, Frecuencia y Valor Monetario de los clientes, y utilizar estos para crear los clusters que identifiquen los segmentos de mercado.

### Regresión para la predicción del total de ventas.

Para el cumplimiento del objectivo de mineria "Predecir las ventas mensuales por producto a partir de los datos históricos" se hará uso de la técnica de regresión lineal simple.

## Construcción de modelos

### Modelos de agrupamiento

Se procede a crear las varias Recency, Frecuency y Monetary

```{r,warning = FALSE}
# Se procede a obtener la fecha de la ultima compra.
ultima_compra <- historic_invoices %>% 
  group_by(CustomerID) %>%
  summarise_at(vars(InvoiceDay),funs(max(.)))
kable(head(ultima_compra,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
colnames(ultima_compra)= c('CustomerID','UltimaCompra')

```

Validamos que todos los clientes fueron considerados:

```{r warning = FALSE}
length(unique(historic_invoices$CustomerID))
length(unique(ultima_compra$CustomerID))
```


```{r warning = FALSE}
visitas_por_cliente <- historic_invoices %>% 
  group_by(CustomerID) %>%
  summarise_at(vars(InvoiceDay),funs(n_distinct(.)))
colnames(visitas_por_cliente)<- c('CustomerID','CantidadVisitas')
kable(head(visitas_por_cliente,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
length(unique(visitas_por_cliente$CustomerID))
```

Total de ventas por cliente

```{r warning = FALSE}

#historic_invoices
#datos <- merge(historic_invoices, ultima_compra, by="CustomerID")
#datos2 <- merge(datos, visitas_por_cliente, by="CustomerID")
#head(datos)
#head(datos2)

total_por_cliente <- historic_invoices  %>% 
  group_by(CustomerID) %>%
  summarise_at(vars(Total),funs(sum(.)))
kable(head(total_por_cliente,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
length(unique(total_por_cliente$CustomerID))


```

Calculamos la frescura de cada cliente:

```{r warning = FALSE}
#Se calcula la recency 
#datos['Recency'] <- as.numeric(difftime(datos$UltimaCompra ,datos$InvoiceDay , units = c("days")))
ultima_compra$Recency <- as.numeric(difftime(max(ultima_compra$UltimaCompra) ,ultima_compra$UltimaCompra , units = c("days")))
head(ultima_compra)
summary(ultima_compra)


hist(ultima_compra$Recency, 
        main = 'Distribución de las frecuencia de las visitas', 
        ylab = 'Observaciones', 
        xlab = 'Cantidad de dias')
```

```{r warning=FALSE}

datos <-  merge(ultima_compra, visitas_por_cliente, by="CustomerID")
datos <- merge(datos,total_por_cliente, by="CustomerID")
head(datos)

```

```{r warning=FALSE}

analysis_date <- lubridate::as_date("2006-12-31", tz = "UTC")
#rfm_result <- rfm_table_order(datos, 
#                              customer_id=CustomerID, 
#                              order_date=UltimaCompra, 
#                              revenue=Total,
#                              max(datos$UltimaCompra))
rfm_result <- rfm_table_order(historic_invoices, 
                              customer_id=CustomerID, 
                              order_date=InvoiceDay, 
                              revenue=Total,
                              max(historic_invoices$InvoiceDay))
#summary(rfm_result)
rfm_result
```


##### Construcción del modelo #1 (Kmedoids)

Para el modelo #1 se hace uso de la técnica Kmedoids.

Para realizar la segmentación de cliente se empleará el análisis RFM para tratar crear variables adicionales, y tratar de agrupar a los clientes según sus caracteristicas.

RFM significa Frescura(Recency) - Frecuencia - Valor monetario. Para efectos del trabajo se intentará identificar si es posible agrupar a los clientes de la compañia analizada en las siguientes categorias.

* Valor bajo: clientes que son menos activos que otros, no son compradores o visitantes muy frecuentes y generan ingresos muy bajos, cero, tal vez negativos.

* Valor medio: en el medio de todo. A menudo, utilizando nuestra plataforma (pero no tanto como nuestros valores altos), es bastante frecuente y genera ingresos moderados.

* Alto valor: el grupo que no queremos perder. Alto ingreso, frecuencia y baja inactividad.

##### Selección de los parámetros modelo #1 (Kmedoids)

Para el primer modelo se analizarán las variables Total y Country.

Para la determinación del valor más apropiado de K se evaluaron métodos como silhouette, método del codo y estadística gap y finalmente basado en los resultados obtenidos se propone hacer uso de un k=3


*Determinar los clusters optimos*

Para la selecion del numero optimo de clusters a crear, utilizamos 3 técnicas:

* Silhoutte

* Método del codo

Otra técnica comunmente utilizada, la estadística gap, no será evaluada, dado que al intentar ejecutarla no se logró que el proceso terminara satisfactoriamente.

A continuación se muestran los resultados de estas técnicas:

```{r warning=FALSE,cache=TRUE}
rfm_clustering<-rfm_result$rfm[,c("recency_days","transaction_count","amount")]
rfm_clustering <- na.omit(rfm_clustering)

str(rfm_clustering)

clusters_kmedoids<-pam(rfm_clustering,3)

resultado_medoids <- data.frame(clusters_kmedoids$cluster,rfm_result$rfm)
head(resultado_medoids,20)
# cálculo del score Silhouette
score_sil<- silhouette(clusters_kmedoids,daisy(rfm_clustering))

# cálculo del valor óptimo de k usando el score silhouette
fviz_nbclust(rfm_clustering,pam,method = 'silhouette',k.max = 10)

# cálculo del valor óptimo de k usando el método del codo
fviz_nbclust(rfm_clustering,pam,method = 'wss',k.max = 10)

# cálculo del valor óptimo de k usando la estadística gap
#fviz_nbclust(rfm_clustering,pam,method = 'gap_stat',k.max = 10)

```

Como se muestra en los graficos anteriores, el método de Silhoutte y el método del codo, parecen mostrar 2 cortes para identificar la cantidad de clusteres óptimos con los valores de 3 y 6. *Considerando que el requerimiento del negocio es agrupar a los clientes en 3 segmentos se utiliza este valor para k, para la creación del número de clusters.*


```{r warning=FALSE}
# cluster al que se asignó cada individuo
clusteres_medoids <- clusters_kmedoids$clustering
#clusteres_medoids
# Descripción de los clusters
medoids <- clusters_kmedoids$medoids
medoids_df <- data.frame(cluster=c("1","2","3"),clusters_kmedoids$medoids, stringsAsFactors = FALSE)

medoids_df$Tecnica<-"KMedoids"

kable(medoids_df,"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
medoids_df
```

Como podemos observar en los medoides, los clientes corresponden a grandes rasgos a los siguientes 3 clusters:

* Clientes de bajo valor: Corresponden a los clientes del cluster 3, que tienen pocas compras, de un monto bajo, y no compran recientemente.

* Clientes de valor medio: Corresponden a los clientes del cluster 2, que tienen una cantidad media de compras, compran recientemente, y montos de compras medios

* Clientes de alto valor: Corresponden a los clientes del cluster 1, que tienen una cantidad alta de compras, recientes, y de montos más altos

Podemos observar la visualizacion de los clusters en el siguiente grafico:

```{r warning=FALSE}
# visualización de los clusters
fviz_cluster(clusters_kmedoids,data=rfm_clustering,palette='jco')
```

Adicionalmente podemos observar la cantidad de clientes asignados a cada cluster:

```{r warning=FALSE}

clusters_df<-data.frame(clusters=clusters_kmedoids$clustering)
ggplot(clusters_df,aes(clusters)) +
  geom_bar()+
  scale_y_continuous(name="Numero de Clientes", labels = scales::comma) +
  labs(x="Cluster Asignado")+
  ggtitle("Clientes por Cluster")

```



##### Construcción del modelo #2 (Kmeans)

```{r warning=FALSE}
clusters <- kmeans(rfm_clustering,3,nstart=20)
clusteres_kmeans <- clusters$cluster

# crear un data frame combinando el cluster asignado y los atributos originales
resultado_kmeans <- data.frame(clusters$cluster,rfm_clustering)
head(resultado_kmeans)

```

De los clusteres anteriores se puede observar como la variable recency no parece tener tanta significancia y los grupos tienen a tener una relación en cuanto al valor monetario invertido por cada cliente.

```{r warning=FALSE}
#obtener cantidad de registros en cada cluster y los centroides
centroides<- data.frame(clusters$size,clusters$centers)
centroides$Tecnica<-"KMeans"
centroides$clusters.size<-NULL
centroides$cluster<-rownames(centroides)
centroides
```

Como podemos observar en los clusters, los clientes corresponden a grandes rasgos a los siguientes 3 clusters:

* Clientes de bajo valor: Corresponden a los clientes del cluster 2, que tienen pocas compras, de un monto bajo, y no compran recientemente.

* Clientes de valor medio: Corresponden a los clientes del cluster 1, que tienen una cantidad media de compras, compran recientemente, y montos de compras medios

* Clientes de alto valor: Corresponden a los clientes del cluster 3, que tienen una cantidad alta de compras, no son compras tan recientes, pero de montos más altos

###### Descripción del modelo obtenido (Incluya al menos un gráfico)

Loa gráficos siguientes nos permiten observar como en el caso de los 3 clusteres formados, los clusters que van del año 1980 al 1990 se observan más dispersos y es posible observar un valor anormal o outlier en este rango. 
```{r warning=FALSE}
ggplot(rfm_clustering,aes(rfm_clustering$recency_days,rfm_clustering$amount, color = clusters$cluster)) + geom_point()+
  ggtitle(label='Distribución por cluster Antiguedad vs Monto de Compras') + 
  scale_color_viridis(option = "D") +
  labs(y="Monto de las transacciones",x="Dias desde la compra más reciente")


ggplot(rfm_clustering,aes(rfm_clustering$transaction_count,rfm_clustering$amount, color = clusters$cluster)) + geom_point()+
  ggtitle(label='Distribución por cluster Monto de Compras vs Cantidad de Compras') + 
  scale_color_viridis(option = "D") +
  labs(y="Monto de las transacciones",x="Numero de compras totales")


ggplot(rfm_clustering,aes(rfm_clustering$recency_days,rfm_clustering$transaction_count, color = clusters$cluster)) + geom_point()+
  ggtitle(label='Distribución por cluster Antiguedad vs Cantidad de Compras') + 
  scale_color_viridis(option = "D") +
  labs(y="Numero de compras totales",x="Dias desde la compra más reciente")

```

El siguiente gráfico muestra el detalle de los clusters creados.

```{r warning=FALSE}
# otra forma de visualizar los clusters
fviz_cluster(clusters,data=rfm_clustering,palette='jco',ggtheme = theme_minimal())
```

```{r warning=FALSE}
clusters_dfkmeans<-data.frame(clusters=clusters$cluster)
ggplot(clusters_dfkmeans,aes(clusters)) +
  geom_bar()+
  scale_y_continuous(name="Numero de Clientes", labels = scales::comma) +
  labs(x="Cluster Asignado")+
  ggtitle("Clientes por Cluster")
```

```{r warning=FALSE}

export_df<-rfm_result$rfm
export_df$kmedoids<-clusters_kmedoids$clustering
export_df$kmeans<-clusters$cluster
head(export_df)
summary(export_df)

export_df<- merge(x=export_df,y=clientes_pais,by.x="customer_id",by.y="CustomerID")
head(export_df)
summary(export_df)


export_df<-export_df %>% 
  mutate(kmeans = replace(kmeans, kmeans == 1, "2 Medio Valor")) %>%
  mutate(kmeans = replace(kmeans, kmeans == 3, "1 Alto Valor")) %>%
  mutate(kmeans = replace(kmeans, kmeans == 2, "3 Bajo Valor")) %>%
  mutate(kmedoids = replace(kmedoids, kmedoids == 2, "2 Medio Valor")) %>%
  mutate(kmedoids = replace(kmedoids, kmedoids == 1, "1 Alto Valor")) %>%
  mutate(kmedoids = replace(kmedoids, kmedoids == 3, "3 Bajo Valor"))

write.csv(export_df,"resultado_cluster.csv")

centroides2<-centroides %>% 
  mutate(cluster = replace(cluster, cluster == "1", "2 Medio Valor")) %>%
  mutate(cluster = replace(cluster, cluster == "3", "1 Alto Valor")) %>%
  mutate(cluster = replace(cluster, cluster == "2", "3 Bajo Valor"))

medoids_df2 <- medoids_df %>%
  mutate(cluster = replace(cluster, cluster == "2", "2 Medio Valor")) %>%
  mutate(cluster = replace(cluster, cluster == "1", "1 Alto Valor")) %>%
  mutate(cluster = replace(cluster, cluster == "3", "3 Bajo Valor"))


export_clusters <- rbind(medoids_df2,centroides2)

write.csv(export_clusters,"centros_clusters.csv")
```

```{r warning=FALSE}
mdf<-medoids_df2
mdf$Tecnica<-NULL
colnames(mdf)<-c("Segmento","Antiguedad","Cantidad de Transacciones","Montos")
kable(mdf,"html", booktabs = T)%>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F, position = "left")
```


### Modelos de regresión

Para este proyecto se emplearán las técnicas de regresión simple y regresión múltiple a fin de comparar los resultados de ambas al realizar la predicción de las ventas.

#### Selección de los parámetros

Para la construccion de los modelos de regresión se trabajara con el campo InvoiceDay y los montos de ventas, a fin de realizar la agregación de las ventas por la fecha de compras y poder monitorear el comportamiento mensual de las mismas y a partir de estos datos generar otras variables que nos sean de utilidad para la predicción. 

```{r warning=FALSE}
#datos_ge$YearMonth <- format(as.Date(datos_ge$InvoiceDay), "%Y-%m")
compras <- retail %>% 
  group_by(InvoiceDay) %>%
  summarise_at(vars(Total),funs(sum(.)))

colnames(compras) <- c('Fecha','ventas')
kable(head(compras,10),"html", booktabs = T)%>%
  kable_styling(latex_options = "striped")
```

A continuación el siguiente gráfico muestra el comportamiento de las ventas de forma mensual.

```{r warning=FALSE}
plot(x = compras$Fecha, y = compras$ventas, main = 'Ventas Mensuales', xlab = 'Fecha',  ylab = 'Ventas totales mensuales', type="l")

```

El siguiente paso a ejecutar es comparar la diferencia en ventas con la fecha predecesora.

```{r warning=FALSE}
compras_diferencia <- compras
compras_diferencia['ventas_previas'] <- shift(compras_diferencia$ventas,n=1,fill=0)
compras_diferencia <- na.omit(compras_diferencia)
# se procede a calcular la diferencia

compras_diferencia['diferencia'] <- compras_diferencia$ventas - compras_diferencia$ventas_previas
```

Al analizar el comportamiento de la diferencia de las ventas a lo largo del tiempo se observa que el comportamiento de las mismas no pareciera tener un comportamiento estacionario, sino que se mantiene constante a lo largo del anno, exceptuando el mes de mayo, el cual es el mes en que se celebra el dia de la madre en la mayoria de paises y puede ser un indicador del incremento de las ventas durante este mes.

```{r}
plot(x = compras_diferencia$Fecha, y = compras_diferencia$diferencia,  main = 'Diferencia de Ventas Mensuales',  xlab = 'Fecha',  ylab = 'Ventas totales mensuales', type="l")
```
Posterior a esto se procede a crear las variables lag, las cuales nos permiten representar como columnas las ventas y el comportamiento de las mismas durante el periodo de un año.

La razón por la cual se crean 13 variables lag es debido a que por cada mes se tienen observaciones unicamente de alrededor de 13 dias.

```{r}
for (inc in 1:13){
  field_name = paste('lag',toString(inc),sep = '')
  compras_diferencia[field_name] <- shift(compras_diferencia$diferencia,n=inc,fill=0)
}

colnames(compras_diferencia) <- c('Fecha', 'Ventas', 'Ventas_previas', 'diff', 'lag1','lag2','lag3','lag4','lag5','lag6','lag7','lag8','lag9','lag10','lag11','lag12','lag13')

```

```{r}
#Se particiona el dataset en entrenamiento y prueba.
#entrenamiento = compras_diferencia[compras_diferencia$Fecha <= '2011-10-31',]
#prueba  = compras_diferencia[compras_diferencia$Fecha >= '2011-10-31',]
sample = sample.split(compras_diferencia$diff, SplitRatio = .75)
entrenamiento = subset(compras_diferencia, sample == TRUE)
prueba  = subset(compras_diferencia, sample == FALSE)
```

Se utiliza la función cor para identificar la correlación entre las 14 variables lag y su correspondiente relación con la fecha precedente.

Como se puede apreciar en la matriz de correlación a continuación, la mayoria de variables no pareciera presentar una correlación fuerte, siendo alrededor de 50 y 52% las variables que presentan una mayor correlación, por ejemplo entre la variable lag1 y lag2 se observa una correlación negativa del -52.88%.

```{r}
cor(entrenamiento[4:17])
```


#### Modelo de Regresión lineal simple

Para le modelo de regresión simple se utilizara únicamente la variable lag1.

```{r}
#Se crea la regresion lineal simple para la diferencia de las ventas
modelo.simple <- lm(diff ~ lag1, data = entrenamiento)
#ver detalle del modelo
summary(modelo.simple)

```

Al analizar la significancia estadistica de la variable lag1 se puede observar que esta presenta una alta significancia, para el modelo de predicción.

##### Evaluación Modelo de regresión lineal simple

Podemos ver que los residuos del modelo se encuentran cercanos a cero lo cual es indicador que el modelo se comporta de manera esperada.

````{r}
# Ver distribución de los residuos del modelo
plot(x = entrenamiento$diff,
     y = modelo.simple$residuals,
     main = 'Residuos del Modelo de regresión simple en entrenamiento',
     xlab = 'Valor',
     ylab = 'Residuos')
````

```{r}
#Se realizan las predicciones empleando el conjunto de datos de entrenamiento.
entrenamiento$Prediccion <- predict(modelo.simple)

# predecir valores de diff en el conjunto de datos de prueba
prueba$Prediccion <- predict(modelo.simple, newdata = prueba)
```

````{r}
confint(modelo.simple)
#Residual Standard Error (RSE)
sigma(modelo.simple)/mean(prueba$diff)
````

```{r}
resultados_rs <- rbind(entrenamiento,prueba)
resultados_rs$Modelo <- 'Regresión Simple'
```

##### Comparación de ventas reales vrs prediciones

Como se puede apreciar en los gráficos a continuación la predición de diferencias de las ventas se comporta de manera muy similar a las ventas históricas. Durante el mes de mayo se observa una variación en las ventas reales, se observa un incremento en las ventas y posterior a esto una disminución, en el caso de las predicciones pareciera que el modelo no parecer ser capaz de predecir este comportamiento el cual podria analizarse si es una anomalia o si por el contrario se debe sobreajustar el modelo para que sea capaz de predecir estos cambios.

```{r}
par(mfrow = c(2,1))
plot(x = entrenamiento$Fecha, y = entrenamiento$diff, 
     main = 'Ventas Mensuales Reales', 
     xlab = 'Fecha', 
     ylab = 'Ventas totales mensuales', type="o" ,col = "red")
lines(entrenamiento$Prediccion, type = "o", col = "blue")

plot(x = entrenamiento$Fecha, y = entrenamiento$Prediccion, 
     main = 'Ventas Mensuales Predicion', 
     xlab = 'Fecha', 
     ylab = 'Ventas totales mensuales', type="o" ,col = "blue")
#lines(entrenamiento$Prediccion, type = "o", col = "blue")
```

#### Modelos Regresión Multiple

##### Modelo de regresión lineal múltiple 0 (Modelo con las 12 variables)

A fin de reforzar los resultados del modelo de regresion lineal, se crea un modelo de regresion múltiple con las variables creadas con la diferencia de las ventas de las 13 fechas predecesoras a las compras realizadas.

````{r}
#Para la creación del modelo 1 se empezará por un modelo "completo" 
modelo.multiple0 <- lm(diff ~ . , data = entrenamiento[,4:15])
# ver el detalle del resumen
summary(modelo.multiple0)
```

Como se observa anteriormente los resultados del modelo de regresión múltiple muestra como las variables más significativas son las variables de los 7 fechas subsecuentes. (Variables del Lag1 al Lag7)

###### Evaluación Modelo Regresión Múltiple 1

Nuevamente en este modelo se observa como la distribución de los residuos del modelo se centra en cero, lo cual es indicador de que el modelo presenta un comportamiento normal.

````{r}
# Ver distribución de los residuos del modelo
par(mfrow = c(1,2))
plot(x = entrenamiento$diff,
     y = modelo.multiple0$residuals,
     main = 'Residuos del Modelo de Regresión Múltiple entrenamiento',
     xlab = 'Valor',
     ylab = 'Residuos')
````

```{r}
#Predicción usando los datos de entrenamiento.
entrenamiento$Prediccion <- predict(modelo.multiple0)

# predecir valores de la diferencia de compras usando el dataset de pruebas
prueba$Prediccion <- predict(modelo.multiple0, newdata = prueba[,4:15])

#entrenamiento[,c(1,4,18)]
#prueba[,c(1,4,18)]

```

##### Comparación de ventas reales vrs prediciones

Como se puede apreciar en los gráficos a continuación la predición de la diferencia de las ventas se comporta de manera muy similar a las ventas históricas, de igual manera se observa que el modelo se comporta de forma muy similar al comportamiento de regresión lineal simple.

```{r}
par(mfrow = c(2,1))
plot(x = entrenamiento$Fecha, y = entrenamiento$diff, 
     main = 'Ventas Mensuales Reales', 
     xlab = 'Fecha', 
     ylab = 'Ventas totales mensuales', type="o" ,col = "red")
lines(entrenamiento$Prediccion, type = "o", col = "blue")

plot(x = entrenamiento$Fecha, y = entrenamiento$Prediccion, 
     main = 'Ventas Mensuales Predicion', 
     xlab = 'Fecha', 
     ylab = 'Ventas totales mensuales', type="o" ,col = "blue")

```

Para extraer el intervalo de confianza del modelo se utiliza la función confint

````{r}
confint(modelo.multiple0)
#Residual Standard Error (RSE)
sigma(modelo.multiple0)/mean(prueba$diff)
````



Se procede a exportar los datos a un archivo csv para la creación de los dashboards


```{r}
#entrenamiento$Observacion <- 'entrenamiento'
#prueba$Observacion <- 'prueba'
resultados_rm <- rbind(entrenamiento,prueba)
resultados_rm$Modelo <- 'Regresión Multiple'


resultado_regresion <- rbind(resultados_rs,resultados_rm)
write.csv(resultado_regresion, "resultado_regresion.csv")
```

## Evaluación de los modelos y selección

### Clustering - Kmedoids
En el caso de los algoritmos de clustering se propone emplear el modelo de kmedoids, considerando que tras analizar el comportamiento de las ventas mensuales, se observa que existen observaciones fuera de rango durante el mes de mayo, que el modelo de kmedoids es capaz de procesar de mejor forma en comparación de kmeans.

### Regresión - Regresión Múltiple

A pesar de que los resultados obtenidos por ambos modelos, no se consideran buenos debido a la alta tasa de error, si se recomienda usar el modelo de regresión múltiple el cual es el que ofrece los mejores resultados.

# Dashboard 

Para la representación de los resultados se crearon 2 Dashboards los cuales muestran los resultados de los modelos de clustering y responden a la pregunta de los diferentes segmentos de mercado que se encontraron a través de las caracteristicas de las compras de los clientes, basado en su antiguedad, frecuencia de compras y montos de compra.

El segundo dashboard presenta los resultados del modelo de regresión multiple y lineal para la predicción de las ventas.

Los dashboard publicados se encuentran disponibles a través de Tableau Public.

* https://public.tableau.com/profile/eilyn.francinie.salazar.miranda#!/vizhome/ProyectoFinal_CursoMineria_EspecializacionCD/Resumensegmentosdemercado?publish=yes
